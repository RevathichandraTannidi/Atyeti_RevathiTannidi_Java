1. Collection Hierarchy & Contracts
Collection, List, Set, Map, Queue â€” understand how these interfaces behave differently.

Contracts of each:

Set: No duplicates

List: Maintains insertion order and allows duplicates

Map: Key-value pair, unique keys

ðŸ”¸ 2. Mutability and Backing Behavior
How Arrays.asList() creates a fixed-size list backed by the array

How subList() shares the same underlying list (modification affects both)

List<String> original = new ArrayList<>(List.of("A", "B", "C"));
List<String> view = original.subList(1, 3);
view.set(0, "Z");
System.out.println(original); // Output: [A, Z, C]
ðŸ”¸ 3. Fail-Fast vs Fail-Safe Iterators
Behavior when you modify a collection while iterating:

ArrayList, HashMap â†’ Fail-Fast

ConcurrentHashMap â†’ Fail-Safe

ðŸ”¸ 4. Equality and Hashing
How Set and Map use equals() and hashCode() to detect duplicates

Behavior when equals() or hashCode() is not overridden

ðŸ”¸ 5. Order and Sorting Behavior
HashSet / HashMap: No guaranteed order

LinkedHashSet / LinkedHashMap: Maintains insertion order

TreeSet / TreeMap: Sorted based on natural ordering or Comparator

ðŸ”¸ 6. Identity vs Logical Equality
IdentityHashMap uses == instead of equals() for key comparison

Different behavior than HashMap for same-looking keys

Map<String, String> map = new IdentityHashMap<>();
map.put(new String("key"), "value1");
map.put(new String("key"), "value2");
System.out.println(map.size()); // Output: 2
ðŸ”¸ 7. Thread-Safety Behavior
Collections.synchronizedList() vs CopyOnWriteArrayList

ConcurrentHashMap behavior during concurrent updates

ðŸ”¸ 8. Immutable Collections
Java 9+ methods like List.of(), Set.of() â†’ throw exception on modification


List<String> list = List.of("a", "b");
list.add("c"); // Throws UnsupportedOperationException


methods:

E get(int index);           // Give me the element at position 'index'
E set(int index, E element); // Replace the element at 'index'
void add(int index, E element); // Insert at position
E remove(int index);        // Remove element at position
int indexOf(Object o);      // First index of an element
int lastIndexOf(Object o);  // Last index of an element
List<E> subList(int from, int to); // A slice of me!
